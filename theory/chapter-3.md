<div align="center">

# Глава 3: Функции

</div>

<br />

<div align="center">

## Функции

</div>

Для создания функции требуется написать ключевое слово `function`, за которым следует написать имя функции, круглые скобки и фигурные скобки.

**Пример 1.1.** Объявление функции.
```js
function doSomething() {}
```

Здесь:
- `function` — ключевое слово, которое означает создание новой функции;
- `doSomething` — имя функции;
- `()`(круглые скобки) — список параметров функции (список входных данных);
- `{}` (фигурные скобки) — тело функции, где мы будем описывать что она делает.



<br />

<div align="center">

### Имя функции

</div>

**Имя функции** — это ключевое слово, по которому в дальнейшем мы будем обращаться к этой функции.

Имя функции может быть любым, но крайне желательно следовать уже готовым правилам Javascript-сообщества:
1. Название функции должно начинаться со строчной буквы (исключения — классы и конструкторы, но о них сильно позже).
2. Название функции должно обозначать то, что именно делает функция.

**Пример 1.2.** Правильные названия функций.
```js
// Мы не знаем что делают эти функции.
// Однако благодаря правильному названию можем сделать предположение.
function setTime() {}
function createUser() {}
function updateArticle() {}
function findArticleByDate() {}
```

<br />

**Пример 1.3.** Неправильные названия функций.
```js
// По таким названиям мы не можем даже предположить что делают эти функции.
function apple() {}
function time1020 () {}
function vasya() {}
```





<br />

<div align="center">

### Вызов функции

</div>

Код в теле функции будет игнорироваться до тех пор, пока функция не будет вызвана.

**Пример 1.4.** Вывод в консоль будет проигнорирован.
```js
function printToConsole() {
  console.log('Этот текст не будет выведен в консоль');
}
```

<br />

**Вызов функции** — это запуск её внутреннего кода. Для вызова функции достаточно написать её имя и круглые скобки.

**Пример 1.5.** Запуск функции.
```js
function printToConsole() {
  console.log('Этот текст будет выведен в консоль');
}

printToConsole();
// Этот текст будет выведен в консоль
```

<br />

В теле функции может быть любой JavaScript-код.

**Пример 1.6.** Несколько инструкций в теле функции.
```js
function calculate() {
  const a = 10;
  const b = 20;
  const result = a + b;
  console.log(result);
}

calculate();
// 30
```



<br />

---

<details><summary><b>Проверьте себя</b></summary>

##### 1. Какой будет вывод в консоль?

```js
function test() {
  console.log('Вывод в консоль')
}
```

<details><summary><b>Ответ</b></summary>
<p>

**Ответ:** В консоль ничего не будет выведено.

Так как отсутствует вызов функции, то код функции `test` не будет выполнен.

</p>
</details>

<br />

##### 2. Какой будет вывод в консоль?

```js
function test() {
  console.log('Вывод в консоль')
}

test();
```

<details><summary><b>Ответ</b></summary>
<p>

**Ответ:** `Вывод в консоль`.

</p>
</details>

</details>

---



<br />
<br />

<div align="center">

## Для чего нужны функции

</div>

У функций есть несколько основных применений:
1. Выполнение кода по требованию.
2. Переиспользование кода.
3. Разделение кода на логические части.



<br />

<div align="center">

### Применение кода по требованию

</div>

Не весь код нужно выполнить сразу после запуска JavaScript-файла. Например:
- включить музыку — только после нажатия на кнопку воспроизведения;
- увеличить общую стоимость товаров — только после добавления товара в корзину;
- изменить рейтинг фильма — только после нажатия на кнопку лайка или дизлайка.

Так как функции — это код запускаемый только при вызове, то у нас появляется возможность вызывать этот код когда он нам понадобится.

Так как в рамках данного курса мы рассматриваем базу JavaScript, то как вызывать функции по определенным событиям (нажатие кнопки, отправка формы и т.п.) будет рассмотрено в рамках другого курса: "JavaScript в браузере".



<br />

<div align="center">

### Переиспользование кода (избежание повторений)

</div>

Функцию можно вызвать неограниченное количество раз. Каждый вызов функции будет выполнять тот код, который находится в теле функции.

Допустим, вам нужно вывести в консоль числа от 1 до 10, и далее ниже по коду еще раз вывести числа от 1 до 10.

**Пример 2.1.** Вывод в консоль чисел от 1 до 10.
```js
console.log(1);
console.log(2);
console.log(3);
console.log(4);
console.log(5);
console.log(6);
console.log(7);
console.log(8);
console.log(9);
console.log(10);

// Какой-то код

console.log(1);
console.log(2);
console.log(3);
console.log(4);
console.log(5);
console.log(6);
console.log(7);
console.log(8);
console.log(9);
console.log(10);
```

<br />

Получилось достаточно громоздко.

А теперь перепишем код с использованием функций.

**Пример 2.2.** Функция, выводящая в консоль числа от 1 до 10.
```js
function printFromOneToTen() {
  console.log(1);
  console.log(2);
  console.log(3);
  console.log(4);
  console.log(5);
  console.log(6);
  console.log(7);
  console.log(8);
  console.log(9);
  console.log(10);
}

printFromOneToTen();  // Выведет в консоль числа от 1 до 10

// Какой-то код

printFromOneToTen();  // Выведет в консоль числа от 1 до 10
```

<br />

Теперь, где бы ни понадобилось вывести числа от 1 до 10, нам достаточно будет вызвать функцию `printFromOneToTen()`. Таким образом мы получаем возможность переиспользовать написанный код.





<br />

<div align="center">

### Разделение кода на логические части

</div>

Важное требование при программировании — не превращать код в кашу. Код должен быть разделен на логические части, каждая из которых делает только то, для чего предназначена.

Правильно организованный и разделенный код значительно упрощает разработку и дальнейшую поддержку приложения, о чем подробнее будет рассказано на отдельном курсе, посвященном архитектуре и паттернам.





<br />
<br />

<div align="center">

## Стрелочные функции

</div>

**Стрелочные функции** — это функции, который имеют другую форму записи. Они названы так, потому что запись `=>` похожа на стрелку.

**Пример 3.1.** Объявление стрелочной функции.
```js
const doSomething = () => {};
```

<br />

Стрелочные функции имеют несколько отличий от обычных:
1. Стрелочные функции обязательно должны быть присвоены какой-либо переменной, или записаны в аргументы функции.

**Пример 3.2.** Ошибка! Отсутствует присваивание стрелочной функции переменной или аргументу.
```js
() => {}
```

<br />

И еще два отличия, которые мы разберем в следующих главах:

2. Стрелочные функции не имеют псевдомассива `arguments`.
3. Стрелочные функции не имеют своего контекста `this` (что это такое — будет в главе про объекты).

В остальном же, стрелочные функции ничем от обычных не отличаются.





<br />
<br />

<div align="center">

## Объявление функции и функциональное выражение

</div>

**Объявление функции (Function Declaration)** — это написание функции с помощью ключевого слово `function` и имени.

**Пример 4.1.** Объявление функции.
```js
function doSomething() {}
```

<br />

**Функциональное выражение (Function Expression)** — это присваивание функции в переменную. В таком случае, имя функции можно опустить.

**Пример 4.2.** Функциональное выражение.
```js
const doSomething = function () {}
```

<br />

Все стрелочные функции являются функциональным выражением.

**Пример 4.3.** Пример функционального выражения для стрелочной функции.
```js
const doSomething = () => {}
```





<br />

<div align="center">

### Отличие объявления функции от функционального выражения

</div>

Объявление функции позволяет вызывать её как до создания, так и после.

Пример ниже будет работать корректно.

**Пример 4.4.** Вызов функции после её объявления.
```js
function doSomething() {
  console.log('Этот текст будет выведен в консоль');
  // Этот текст будет выведен в консоль
}

doSomething();
```

<br />

И следующий пример сработает корректно.

**Пример 4.5.** Вызов функции до её объявления.
```js
doSomething();

function doSomething() {
  console.log('Этот текст будет выведен в консоль');
  // Этот текст будет выведен в консоль
}
```

<br />

Функциональное выражение может быть вызвано **ТОЛЬКО** после создания.

Пример ниже отработает корректно.

**Пример 4.6.** Вызов функционального выражения после его объявления.
```js
const doSomething = function () {
  console.log('Этот текст будет выведен в консоль');
}

doSomething();
```

<br />

При вызове функционального выражения до его объявления произойдет ошибка.

**Пример 4.7.** Ошибка! Вызывать функциональные выражения до их объявления нельзя!
```js
doSomething();
// ReferenceError: doSomething is not defined

const doSomething = function () {
  console.log('До этого вывода в консоль дело не дойдет');
}
```

<br />

Почему так происходит мы рассмотрим в главе про Контекст Выполнения.

В остальном же нет отличий между двумя видами объявления функций.





<br />
<br />

<div align="center">

## Аргументы функции

</div>

**Аргументы** — это набор значений/переменных, которые мы передаем внутрь функции. Аргументы передаются при вызове функции в круглых скобках.

**Пример 5.1.** Передача аргументов в функцию.
```js
function doSomething() {}

doSomething('Первый аргумент', 'Второй аргумент', 'Третий аргумент');
```

<br />

Аргументов может быть любое количество. Тип данных аргумента может быть любым.

**Пример 5.2.** Передача аргументов разных типов в функцию.
```js
function doSomething() {}

doSomething(5, -10, true, { login: 'admin' }, [], 'Строка');
```





<br />
<br />

<div align="center">

## Псевдомассив `arguments`

</div>

Переданные в функцию аргументы можно использовать внутри тела функции.

**Пример 6.1.** Вывод в консоль псевдомассива `arguments`.
```js
function doSomething() {
  console.log(arguments);
  // { 0: 'one', 1: 'two', 2: 'three', length: 3 }
}

doSomething('one', 'two', 'three');
```

<br />

Псевдомассив `arguments` не нужно объявлять — в каждой функции он создается автоматически.

**Псевдомассив** — это не массив, это объект, значения которого доступны по индексам от 0 и до количества переданных значений. В нашем случае:
- Индекс 0 — значение `'one'`
- Индекс 1 — значение `'two'`
- Индекс 2 — значение `'three'`

Также у псевдомассивов есть свойство `length`, по которому мы можем узнать количество значений внутри псевдомассива.

**Пример 6.2.** Вывод в консоль элементов псевдомассива и свойства `length`.
```js
function doSomething() {
  console.log(arguments[0]);      // one
  console.log(arguments[1]);      // two
  console.log(arguments[2]);      // three
  console.log(arguments.length);  // 3
}

doSomething('one', 'two', 'three');
```

<br />

> Больше подробностей про псевдомассивы будет в главе про массивы.





<br />

<div align="center">

### Примеры использования `arguments`

</div>

Аргументами мы можем распоряжаться по собственному желанию. Например, вывести их в консоль.

**Пример 6.3.** Вывод в консоль аргументов.
```js
function printUserName() {
  console.log('Имя пользователя: ' + arguments[0] + ' ' + arguments[1]);
}

printUserName('John', 'Smith');
// Имя пользователя: John Smith

printUserName('Jack', 'Daniels');
// Имя пользователя: Jack Daniels
```

<br />

Для более удобного использования аргументов внутри функции, каждый из них можно поместить в переменную.

**Пример 6.4.** Помещаем аргументы в переменные.
```js
function calculateSum() {
  const num1 = arguments[0];
  const num2 = arguments[1];

  console.log(`Сумма чисел: ` + (num1 + num2));
}

calculateSum(10, 15);
// Сумма чисел: 25

calculateSum(40, -5);
// Сумма чисел: 35
```



<br />

<div align="center">

### Псевдомассив `arguments` в стрелочных функциях

</div>

Как уже говорили ранее, псевдомассива `arguments` в стрелочных функциях не существует.

**Пример 6.5.** Ошибка! `arguments` в стрелочных функциях не существует!
```js
const doSomething = () => {
  console.log(arguments);
  // ReferenceError: arguments is not defined
};

doSomething(1, 2, 3);
```





<br />

<div align="center">

### Минусы псевдомассива `arguments`

</div>

С одной стороны, хранение всех переданных аргументов в одном псевдомассиве — удобная штука, но у `arguments` есть два существенных минуса:

1. `arguments` в стрелочных функциях не существует. А отказываться от стрелочных функций мы не намерены.
2. В JavaScript для работы с массивами встроено множество удобных методов. Но так как псевдомассив — это не полноценный массив, то он этими методами не обладает.



<br />

<div align="center">

### Итог по `arguments`

</div>

В современной разработке псевдомассив `arguments` используется достаточно редко, а для работы со входящими данными предпочтение отдается параметрам. Периодически, вы всё равно будете сталкиваться с `arguments`, поэтому знать о его существовании — обязательно.





<br />
<br />

<div align="center">

## Параметры функции

</div>

<div align="center">

### Параметры

</div>

**Параметры** — это данные, которые принимает функция.

Параметры указываются в круглых скобках при объявлении функции:

**Пример 7.1.** Объявление параметров.
```js
function doSomething(param1, param2, param3) {}

doSomething();
```

<br />

В параметры попадают те значения, которые мы передаем в аргументах при вызове функции.

Если для параметра отсутствует аргумент, то по-умолчанию его значение устанавливается в `undefined`.

**Пример 7.2.** Значение по-умолчанию для параметров.
```js
function doSomething(param1, param2, param3) {
  console.log('Параметр 1: ' + param1);  // Параметр 1: undefined
  console.log('Параметр 2: ' + param2);  // Параметр 2: undefined
  console.log('Параметр 3: ' + param3);  // Параметр 3: undefined
}

doSomething();
```





<br />

<div align="center">

### Передача аргументов в параметры

</div>

Каждый переданный аргумент будет попадать в тот же по индексу параметр функции.

**Пример 7.3.** Передача трех аргументов в три параметра.
```js
function doSomething(param1, param2, param3) {
  console.log('Параметр 1: ' + param1);  // Параметр 1: first
  console.log('Параметр 2: ' + param2);  // Параметр 2: second
  console.log('Параметр 3: ' + param3);  // Параметр 3: third
}

doSomething('first', 'second', 'third');
```

<br />

Если передать больше аргументов, чем объявлено параметров — ничего страшного, лишние аргументы просто будут отсечены.

**Пример 7.4.** Передача большего числа аргументов, чем объявлено параметров.
```js
function doSomething(param1) {
  console.log('Параметр 1: ' + param1);  // Параметр 1: first
}

// Аргументы second и third не будут привязаны ни к какому параметру
doSomething('first', 'second', 'third');
```

<br />

Если указать больше параметров, чем передано аргументов, то у лишних параметров будет установлено значение `undefined`.

**Пример 7.5.** Объявление большего числа параметров, чем передано аргументов.
```js
function doSomething(param1, param2, param3) {
  console.log('Параметр 1: ' + param1);  // Параметр 1: first
  console.log('Параметр 2: ' + param2);  // Параметр 2: undefined
  console.log('Параметр 3: ' + param3);  // Параметр 3: undefined
}

doSomething('first');
```

<br />

В некоторых случаях, нам может потребоваться передать аргументы не всем параметрам, а только некоторым. Чтобы пропустить передачу аргумента, можно вместо него передать `undefined`.

**Пример 7.6.** Передача пустого аргумента.
```js
function doSomething(param1, param2, param3) {
  console.log('Параметр 1: ' + param1);  // Параметр 1: first
  console.log('Параметр 2: ' + param2);  // Параметр 2: undefined
  console.log('Параметр 3: ' + param3);  // Параметр 3: third
}

doSomething('first', undefined, 'third');
```






<br />

<div align="center">

### Имена параметров

</div>

Параметры — это самые обычные переменные. Как и для любой переменной, параметру можно задать какое угодно имя. Но правильным именем параметра будет такое, какое значение параметр ожидает получить.

**Пример 7.7.** Выбор подходящих названий для параметров.
```js
function printUserInfo(name, age) {
  console.log('Имя пользователя: ' + name);     // Имя пользователя: John
  console.log('Возраст пользователя: ' + age);  // Возарст пользователя: 30
}

printUserInfo('John', 30);
```

<br />

**Пример 7.8.** Выбор подходящих названий для параметров.
```js
function calculateSum(num1, num2) {
  console.log(`Сумма чисел: ` + (num1 + num2));  // Сумма чисел: 150
}

calculateSum(100, 50);
```





<br />

<div align="center">

### Параметры по-умолчанию

</div>

**Параметр по-умолчанию (default parameters)** — это значение, которое будет установлено для параметра, если ему не будет передан никакой аргумент, либо значение аргумента будет `undefined`.

Параметры по-умолчанию указываются через оператор присваивания `=` после имени параметра.

В примере ниже мы не передаем никаких аргументов. В таком случае будут использованы параметры по-умолчанию.

**Пример 7.9.** Использование параметров по-умолчанию.
```js
function doSomething(param1 = 'Значение один', param2 = 'Значение два') {
  console.log('Параметр 1: ' + param1);  // Параметр 1: Значение один
  console.log('Параметр 2: ' + param2);  // Параметр 2: Значение два
}

doSomething();
```

<br />

В случае, если аргумент будет присвоен соответствующему параметру, то значение по-умолчанию отбрасывается.

В примере ниже:
- параметру `param1` присваивается аргумент `100`, поэтому его значение по-умолчанию отбрасывается;
- параметру `param2` аргументов не присвоено, поэтому будет взято его значение по-умолчанию.

**Пример 7.10.** Использование значения по-умолчанию только для пустых параметров. 
```js
function doSomething(param1 = 'Значение один', param2 = 'Значение два') {
  console.log('Параметр 1: ' + param1);  // Параметр 1: 100
  console.log('Параметр 2: ' + param2);  // Параметр 2: Значение два
}

doSomething(100);
```

<br />

Если значение аргумента равно `undefined`, то у соответствующего параметра будет использовано значение по-умолчанию.

**Пример 7.11.** Использование значения по-умолчанию для параметра, чей аргумент равен `undefined`.
```js
function doSomething(param1 = 'Значение один', param2 = 'Значение два') {
  console.log('Параметр 1: ' + param1);  // Параметр 1: Значение один
  console.log('Параметр 2: ' + param2);  // Параметр 2: Новое значение
}

doSomething(undefined, 'Новое значение');
```





<br />

<div align="center">

### Примеры параметров по-умолчанию

</div>

Ситуация первая. Допустим, пользователь решил не указывать своего имени, но указал адрес доставки. В таком случае, мы можем задать имя пользователя как `Гость`.

**Пример 7.12.** Ситуация первая.
```js
function printUserInfo(name = 'Гость', address) {
  console.log('Имя пользователя: ' + name);
  // Имя пользователя: Гость

  console.log('Адрес доставки: ' + address);
  // Адрес доставки: Москва, Ходынский бульвар
}

printUserInfo(undefined, 'Москва, Ходынский бульвар');
```

<br />

Ситуация вторая. Для корректного перемножения чисел важно, чтобы были указаны все числа. В случае умножения числа на `undefined` мы получим ошибку. Для избежания этой ошибки воспользуемся параметрами по-умолчанию.

**Пример 7.13.** Ситуация вторая.
```js
function multiply(num1 = 1, num2 = 1) {
  console.log(`Результат перемножения: ` + (num1 * num2));
}

multiply(10, 5);         // Результат перемножения: 50
multiply(10);            // Результат перемножения: 10
multiply(undefined, 5);  // Результат перемножения: 5
```





<br />

<div align="center">

### Остаточные параметры

</div>

Иногда, мы не знаем какое количество аргументов будет передано. Может быть один аргумент, а может быть десять.

Для обработки таких сценариев существуют остаточные параметры.

**Остаточные параметры (rest parameters)** — это массив всех аргументов, которые не были привязаны к другим параметрам.

- Остаточные параметры указываются в конце списка параметров с помощью spread-оператора `...` и любого названия.
- В списке параметров может быть только один остаточный параметр.

**Пример 7.14.** Использование остаточных параметров.
```js
function doSomething(...rest) {
  console.log(rest);  // ['one', 'two', 'three']
}

doSomething('one', 'two', 'three');
```

<br />

Если аргумент был связан с каким-либо параметром, то он не попадет в остаточные параметры.

В примере ниже:
- Аргумент `1` присваивается параметру `param1`
- Аргумент `2` присваивается параметру `param2`
- Аргументы `3`, `4`, `5` попадают в остаточные параметры `rest`

**Пример 7.15.** Использование остаточных параметров.
```js
function doSomething(param1, param2, ...rest) {
  console.log(param1);  // 1
  console.log(param2);  // 2
  console.log(rest);    // [3, 4, 5]
}

doSomething(1, 2, 3, 4, 5);
```

<br />

Если в функцию аргументы не передавались, то остаточные параметры будут в виде пустого массива.

**Пример 7.16.** Значение остаточных параметров в случае отсутствия аргументов.
```js
function doSomething(...rest) {
  console.log(rest);  // []
}

doSomething();
```

<br />

Также остаточные параметры будут пустым массивом, если все аргументы были присвоены другим параметрам.

**Пример 7.17.** Для остаточных параметров не осталось аргументов.
```js
function doSomething(param1, param2, ...rest) {
  console.log(param1);  // 1
  console.log(param2);  // 2
  console.log(rest);    // []
}

doSomething(1, 2);
```





<br />

<div align="center">

### Имена остаточных параметров

</div>

Так как остаточные параметры — это массив, то его имя должно быть соответствующее. Обычно, имя задается во множественном числе и прямо указывает на те данные, что хранит массив.

**Пример 7.18.** Функция принимает в качестве аргументов список имен, тогда остаточные параметры можно назвать как `names`, или `userNames`.
```js
function printNames(...names) {
  console.log(names);  // ['Fedor', 'Vasya', 'Margarita']
}

printNames('Fedor', 'Vasya', 'Margarita');
```

<br />

**Пример 7.19.** Функция принимает в качестве аргументов список чисел, тогда остаточные параметры можно назвать как `numbers`.
```js
function printNumbers(...numbers) {
  console.log(numbers);  // [1, 2, 3]
}

printNumbers(1, 2, 3);
```







<br />
<br />

<div align="center">

## Внешние и локальные переменные

</div>

В рамках функции существуют следующие термины:

- **внешняя переменная** — это переменная, объявленная вне функции;
- **локальная переменная** — это переменная, объявленная в теле функции.

Давайте рассмотрим, где и как мы можем обращаться к этим двум видам переменных.



<br />

<div align="center">

### Внешние переменные

</div>

Функция имеет доступ ко всем внешним переменным, объявленным до момента вызова функции.

В примере ниже, внешняя переменная `name` объявлена до вызова функции, поэтому внутри функции к ней можно обращаться.

**Пример 8.1.** Вывод в консоль внешней переменной.
```js
const name = 'John';

function doSomething() {
  console.log(name); // John
}

doSomething();
```

<br />

В следующем примере, внешняя переменная объявлена после вызова функции, и обращение к ней внутри функции вызовет ошибку.

**Пример 8.2.** Ошибка! Внешняя переменная `name` на момент вывода в консоль еще не создана.
```js
function doSomething() {
  console.log(name); // ReferenceError: name is not defined
}

doSomething();

const name = 'John';
```

<br />

Код программы выполняется сверху вниз. Но когда мы запускаем функцию, выполнение остального кода будет приостановлено до тех пор, пока код в теле функции не будет выполнен.

Разберем пошагово что произошло:
1. Объявляется функция `doSomething()`.
2. Вызывается функция `doSomething()`.
3. Происходит попытка вывести в консоль переменную `name`. Но так как переменная `name` еще не объявлена (то есть её фактически еще не существует), то движок выбрасывает ошибку `ReferenceError: name is not defined`.





<br />

<div align="center">

### Локальные переменные

</div>

Локальные переменные создаются внутри функции. Соответственно, у функции есть полный доступ к ним внутри себя.

**Пример 8.3.** Объявление локальных переменных в теле функции.
```js
function doSomething() {
  const age = 30;
  const country = 'Russia';
  
  console.log(age);      // 30
  console.log(country);  // Russia
}

doSomething();
```

<br />

У внешнего окружения нет доступа к локальным переменным функций.

**Пример 8.4.** Ошибка! Константа `country` существует только внутри функции `doSomething()`.
```js
function doSomething() {
  const country = 'Russia';
}

doSomething();

console.log(country);  // ReferenceError: country is not defined
```

<br />

Данное правило очень простое, но есть нюанс: функции имеют доступ к локальным переменным другой функции только в том случае, если сами находятся в теле этой функции.

**Пример 8.5.** Доступ к локальным переменным из внутренней функции `doAnotherThing()`.
```js
function doSomething() {
  const country = 'Russia';
  
  function doAnotherThing() {
    console.log(country);  // Russia
  }
  
  doAnotherThing();
}

doSomething();
```

<br />

Но как только мы выносим внутреннюю функцию наружу, то доступ к локальным переменным сразу пропадает.

**Пример 8.6.** Ошибка! Константа `country` существует только в теле функции `doSomething()`.
```js
function doAnotherThing() {
  console.log(country);  // ReferenceError: country is not defined
}

function doSomething() {
  const country = 'Russia';
  doAnotherThing();
}

doSomething();
```





<br />
<br />

<div align="center">

## Ссылочные типы данных в качестве аргументов

</div>

Как мы уже знаем, в качестве аргументов можно передавать любые типы данных: числа, строки, объекты, массивы...

Внутри функции, менять примитивные типы данных можно без каких-либо последствий на внешнее окружение.

**Пример 9.1.** Изменение примитивных типов данных в теле функции.
```js
const num = 100;

function changeNumber(number) {
  console.log(number);  // 100

  number = 200;
  console.log(number);  // 200
}

changeNumber(num);

console.log(num);  // 100
```

<br />

Здесь параметр `number` получает значение `100` из первого аргумента, и далее не имеет ничего общего с внешней переменной `num`.

<br />

Со ссылочными типами данных, такими как объект и массив, ситуация другая. Изменение ссылочных типов данных внутри функции также меняет их значение и во внешнем окружении.

Это происходит потому, что аргумент в параметр передает **ссылку** на объект/массив, и далее параметр работает уже с этой ссылкой. То есть фактически, мы работаем с одним и тем же объектом/массивом как снаружи, так и внутри тела функции.

**Пример 9.2.** Изменение свойства `age` у объекта `client` внутри функции повлечет за собой изменение объекта `user` во внешнем окружении.
```js
const user = {
  age: 20
};

function changeAge(client) {
  console.log(client);  // { age: 20 }

  client.age = 40;
  console.log(client);  // { age: 40 }
}

changeAge(user);

console.log(user);  // { age: 40 }
```

<br />

**Пример 9.3.** Изменение первого значения массива `nums` внутри функции, также изменит первое значение и в массиве `numbers` во внешнем окружении.
```js
const numbers = [10, 20, 30];

function changeFirstNumber(nums) {
  console.log(nums);  // [10, 20, 30]

  nums[0] = 99;
  console.log(nums);  // [99, 20, 30]
}

changeFirstNumber(numbers);

console.log(numbers);  // [99, 20, 30]
```





<br />
<br />

<div align="center">

## Возвращение значения

</div>

**Возвращение значения (return value)** — это передача данных из функции наружу.

На данный момент мы знаем, что внешнее окружение не имеет доступа к локальным переменным функций. Но что если нам всё-таки потребуется получить локальные данные из функции?

Для получения данных из функции используется оператор `return`, где после пробела указываются те данные, которые нужно отдать наружу.

На самом деле, каждая функция всегда что-либо возвращает. И если мы не укажем в теле функции оператор `return`, то движок JavaScript сделает это за нас.

**Пример 10.1.** Откуда берется `undefined` при вызове функции.
```js
function doSomething() {
  // return undefined — эта строчка прописывается автоматически в каждой функции
}

console.log(doSomething());
// undefined
// И именно поэтому при вызове функции мы всегда видим в консоле значение `undefined`
```

<br />

Чтобы что-то отдать из функции наружу — требуется только написать `return` и отдаваемое значение.

**Пример 10.2.** Возвращаем из функции значение `Hello`.
```js
function sayHello() {
  return 'Hello';
}

console.log(sayHello());
// Hello
```

<br />

Функции могут возвращать значения переменных.

**Пример 10.3.** Складываем два числа и возвращаем наружу итоговый результат.
```js
function calculateSum(num1, num2) {
  const sum = num1 + num2;
  return sum;
}

console.log(calculateSum(100, 50));
// 150
```

<br />

Возвращаемые значения можно присваивать в переменные для дальнейшей работы с ними.

**Пример 10.4.** Присвоение результата работы функции `calculateSum()` в переменную `result`.
```js
function calculateSum(num1, num2) {
  const sum = num1 + num2;
  return sum;
}

const result = calculateSum(100, 50);
console.log('Сумма чисел равна: ' + result);
// Суммая чисел равна: 150
```

<br />

Если мы укажем несколько возвращаемых значений через запятую, то будет возвращено только последнее из перечисленных.

Происходит это потому, что оператор запятой отделяет выражения друг от друга. Далее каждое выражение выполняется и отбрасывается, кроме последнего выражения, результат которого и будет доступен оператору `return`.

**Пример 10.5.** Только последнее значение будет отдано наружу.
```js
function doSomething() {
  return 10, 20, 30, 40;
}

const result = doSomething();
console.log(result);
// 40
```

<br />

Чтобы вернуть несколько значений из функции, их требуется поместить в массив (или объект).

**Пример 10.6.** Возвращение нескольких значений в виде массива.
```js
function getInfo(name, age) {
  const nameInfo = 'Имя пользователя: ' + name;
  const ageInfo = 'Возраст пользователя: ' + age;

  return [nameInfo, ageInfo];
}

const result = getInfo('Арнольд', 20);
console.log(result);
// ['Имя пользователя: Арнольд', 'Возраст пользователя: 30']
```



<br />

<div align="center">

### Остановка работы функции

</div>

У оператора `return` есть еще одна особенность — функция немедленно прекращает свою работу. Весь код, который был написан после оператора `return` — не будет выполнен.

**Пример 10.7.** Прекращение работы функции.
```js
function doSeomthing() {
  console.log('Первый');
  return;
  console.log('Второй');
  console.log('Третий');
}

doSeomthing();
// Первый
```






<br />

<div align="center">

## Чистые функции

</div>

**Чистая функция** — это функция, которая при одних и тех же наборах аргументов возвращает одинаковый результат. Также чистая функция не должна никак влиять на внешнее окружение.

**Пример 11.1.** Чистая функция.
```js
function sum(a, b) {
  return a + b;
}

// Сколько бы раз мы ни вызывали функцию sum с аргументами 10 и 5 —
// результат работы функции всегда будет один и тот же: 15
console.log(sum(10, 5));  // 15
console.log(sum(10, 5));  // 15
console.log(sum(10, 5));  // 15

// Аналогично с другими аргументами
console.log(sum(6, 3));  // 9
console.log(sum(6, 3));  // 9
```

<br />

Если вызов функции с одним и тем же набором аргументов возвращает разный результат — то функция не является чистой.

**Пример 11.2.** Не чистая функция, возвращающая случайное число.
```js
function getRandomNumber(arr) {
  // Метод Math.random() — возвращает случайное число от 0 до 1
  return Math.random();
}

// Вызов такой функции всегда возвращает разный результат
console.log(getRandomNumber());  // например, 0.6681267023311694
console.log(getRandomNumber());  // например, 0.730123124663846
console.log(getRandomNumber());  // например, 0.4874166813442693
```

<br />

Если внутри функции меняется внешнее окружение (переменные, объекты, массивы за пределами функции), то такая функция не является чистой.

**Пример 11.3.** Не чистая функция, меняющая внешнее окружение.
```js
let a = 3;
let b = 7;

function changeEnvironment() {
  // Здесь мы меняем внешнее окружение,
  // а значит эта функция не является чистой.
  a = 10;
  b = 20;
}

changeEnvironment();
```



<br />

<div align="center">

### Зачем нужны чистые функции

</div>

Хорошей практикой считается писать чистые функции.

Причины:

1. Не чистые функции, влияющие на окружение, могут привести к неожиданным результатам.

**Пример 11.4.** Не чистая функция, меняющая окружение.
```js
let name = 'John';

function changeName() {
  name = 'Steve';
}

changeName();

// Может возникнуть ситуация, что мы ожидаем в
// переменной name значение 'John', но функция changeName
// поменяла значение на 'Steve'
console.log(name);
// Steve
```

2. Чистые функции гарантируют нам одинаковый результат. Было бы странно, если бы функция суммы двух чисел при передаче аргументов `10` и `5` иногда возвращала бы `15`, а иногда `20`.





<br />
<br />

<div align="center">

## Самовызывающиеся функции

</div>

**Самовызывающаяся функция или немедленно вызываемое функциональное выражение (Immediately-Invoked Function Expressions, IIFE)** — это функция, которая вызывается сразу же после объявления.

Вызвать функцию сразу после объявления можно двумя способами.

**Пример 12.1.** Первый вариант самовызывающейся функции.
````js
(function doSomething() {
  console.log('Этот код будет выполнен немедленно');
})();
// Этот код будет выполнен немедленно
````

<br />

**Пример 12.2.** Второй вариант самовызывающейся функции.
````js
(function doSomething() {
  console.log('Этот код будет выполнен немедленно');
}());
// Этот код будет выполнен немедленно
````

<br />

Круглые скобки в конце конструкции — это набор принимаемых аргументов.

**Пример 12.3.** Передача аргументов в самовызывающуюся функцию.
````js
(function doSomething(str1, str2) {
  console.log(str1 + ' ' + str2);
})('hello', 'world');
// hello world
````

<br />

Из самовызывающейся функции можно вернуть значение точно так же, как и из обычной функции.

**Пример 12.4.** Возвращение значения из самовызывающейся функции.
````js
const result = (function doSomething(a, b) {
  return a + b;
})(10, 5);

console.log(result);
// 15
````

<br />

<div align="center">

### Зачем нужны самовызывающиеся функции

</div>

Идея самовызывающихся функций простая — нам не нужно вызывать такие функции отдельно, плюс они выполняются немедленно. А также самовызывающиеся функции создают внутри себя локальные области видимости, о чем мы еще поговорим отдельно.





<br />
<br />

<div align="center">

## Анонимные функции

</div>

**Анонимные функции** — это функции, которым не задано имя.

Если попробовать написать просто функцию без имени — то возникнет ошибка.

**Пример 13.1.** Ошибка!
```js
function () {
  console.log('Что-то пошло не так');
}
// SyntaxError: Function statements require a function name
```

<br />

Ошибка возникает из-за того, что мы создаем функцию к которой никак нельзя обратиться.

Правило такое: если создаем анонимную функцию, то:
- функция должна быть помещена в переменную или константу;
- или функция должна быть помещена в самовызывающуюся функцию.

**Пример 13.2.** Анонимная функция, помещенная в константу
```js
const doSomething = function () {
  console.log('Этот код отработает корректно');
}

doSomething();
// Этот код отработает корректно
```

<br />

**Пример 13.3.** Анонимная функция, помещенная в самовызывающуюся функцию.
```js
(function () {
  console.log('Этот код тоже отработает корректно');
})()
// Этот код тоже отработает корректно
```

<br />

Все стрелочные функции являются анонимными.

**Пример 13.4.** Анонимная стрелочная функция.
```js
const doSomething = () => {
  console.log('И здесь всё в порядке');
};

doSomething();
// И здесь всё в порядке
```



<br />

<div align="center">

### Зачем нужны анонимные функции

</div>

Если функция помещается в переменную, или используется в самовызывающихся конструкциях, то анонимная функция позволяет сократить код. Сокращение кода небольшое, но всё же это сокращение.






<br />
<br />

<div align="center">

## Заключение

</div>

В данной главе были рассмотрены функции и работа с ними.

После прочтения главы не забывайте:
1. Ответить на контрольные вопросы.
2. Пройти тесты.
3. Прорешать задачи.








<br />
<br />

<div align="center">

## Контрольные вопросы

</div>

1. Что такое имя функции?
2. Как правильно именовать функции?
3. Что такое вызов функции?
4. Для чего нужны функции?
5. Что такое стрелочные функции?
6. В чем отличие обычных функций от стрелочных?
7. Что такое объявление функции и функциональное выражение? В чем разница между ними?
8. Что такое аргументы функции?
9. Что такое псевдомассив?
10. Какие минусы у псевдомассива `arguments`?
11. Что такое параметры функции?
12. Можно ли передать в функцию больше аргументов, чем объявлено параметров? Что будет с лишними аргументами?
13. Можно ли объявить в функции больше параметров, чем передано аргументов? Что будет с лишними параметрами?
14. Что такое параметры по-умолчанию?
15. Что такое остаточные параметры?
16. Что такое внешняя и локальная переменные?
17. Есть ли доступ к внешним переменным в теле функции?
18. Есть ли доступ к локальным переменным функции у внешнего окружения?
19. Что такое возвращение значения?
20. Как вернуть несколько значений из функции?
21. Как прекратить работу функции?
22. Что такое чистая функция? Зачем она нужна?
23. Что такое самовызывающаяся функция? Зачем она нужна?
24. Что такое анонимная функция? Зачем она нужна?
